# IBM MQ Integration Design

## Overview

This document outlines the IBM MQ integration strategy for the Swap Life Cycle Management Service, including message abstraction layer, queue configuration, and error handling.

## Message Abstraction Layer

### Core Interfaces

**Event Publisher Interface**:
```java
public interface EventPublisher {
    /**
     * Publish event to specified queue
     */
    void publish(String queueName, Object event);
    
    /**
     * Publish event with correlation ID
     */
    void publishWithCorrelationId(String queueName, String correlationId, Object event);
    
    /**
     * Publish event asynchronously
     */
    CompletableFuture<Void> publishAsync(String queueName, Object event);
    
    /**
     * Publish event with retry mechanism
     */
    void publishWithRetry(String queueName, Object event, int maxRetries);
    
    /**
     * Publish event to dead letter queue
     */
    void publishToDeadLetterQueue(String originalQueueName, Object event, String errorMessage);
}
```

**Event Consumer Interface**:
```java
public interface EventConsumer {
    /**
     * Subscribe to queue with event handler
     */
    void subscribe(String queueName, EventHandler handler);
    
    /**
     * Subscribe with message selector
     */
    void subscribeWithSelector(String queueName, String selector, EventHandler handler);
    
    /**
     * Subscribe with batch processing
     */
    void subscribeWithBatch(String queueName, EventHandler handler, int batchSize);
    
    /**
     * Unsubscribe from queue
     */
    void unsubscribe(String queueName);
    
    /**
     * Get queue depth
     */
    int getQueueDepth(String queueName);
}
```

**Event Handler Interface**:
```java
@FunctionalInterface
public interface EventHandler {
    void handle(EventMessage message) throws EventProcessingException;
}

public class EventMessage {
    private String messageId;
    private String correlationId;
    private String queueName;
    private Object payload;
    private Map<String, Object> headers;
    private LocalDateTime timestamp;
    private int deliveryCount;
    
    // Constructors, getters, setters
}
```

### IBM MQ Implementation

**IBM MQ Queue Manager**:
```java
@Service
@Slf4j
public class IBMQueueManager implements EventPublisher, EventConsumer {
    
    private final MQQueueManager queueManager;
    private final ObjectMapper objectMapper;
    private final ExecutorService executorService;
    private final Map<String, MQQueue> queues;
    private final Map<String, List<EventHandler>> subscribers;
    private final RetryTemplate retryTemplate;
    
    public IBMQueueManager(MQConfiguration config, ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
        this.executorService = Executors.newFixedThreadPool(config.getThreadPoolSize());
        this.queues = new ConcurrentHashMap<>();
        this.subscribers = new ConcurrentHashMap<>();
        this.retryTemplate = createRetryTemplate();
        
        try {
            this.queueManager = new MQQueueManager(
                config.getQueueManagerName(),
                config.getChannelName(),
                config.getConnectionName(),
                config.getUsername(),
                config.getPassword()
            );
            
            initializeQueues(config.getQueues());
        } catch (MQException e) {
            throw new MQConnectionException("Failed to connect to IBM MQ", e);
        }
    }
    
    @Override
    public void publish(String queueName, Object event) {
        try {
            MQQueue queue = getQueue(queueName);
            MQMessage message = createMessage(event);
            
            retryTemplate.execute(context -> {
                queue.put(message, new MQPutMessageOptions());
                return null;
            });
            
            log.debug("Published event to queue: {}", queueName);
        } catch (Exception e) {
            log.error("Failed to publish event to queue: {}", queueName, e);
            throw new EventPublishingException("Failed to publish event", e);
        }
    }
    
    @Override
    public CompletableFuture<Void> publishAsync(String queueName, Object event) {
        return CompletableFuture.runAsync(() -> publish(queueName, event), executorService);
    }
    
    @Override
    public void subscribe(String queueName, EventHandler handler) {
        subscribers.computeIfAbsent(queueName, k -> new ArrayList<>()).add(handler);
        
        executorService.submit(() -> {
            try {
                MQQueue queue = getQueue(queueName);
                MQGetMessageOptions getOptions = new MQGetMessageOptions();
                getOptions.waitInterval = MQC.MQWI_UNLIMITED;
                
                while (!Thread.currentThread().isInterrupted()) {
                    MQMessage message = new MQMessage();
                    queue.get(message, getOptions);
                    
                    EventMessage eventMessage = createEventMessage(message, queueName);
                    handleMessage(eventMessage, handler);
                }
            } catch (MQException e) {
                log.error("Error consuming from queue: {}", queueName, e);
            }
        });
    }
    
    private void handleMessage(EventMessage eventMessage, EventHandler handler) {
        try {
            handler.handle(eventMessage);
        } catch (EventProcessingException e) {
            log.error("Error processing message: {}", eventMessage.getMessageId(), e);
            handleProcessingError(eventMessage, e);
        }
    }
    
    private MQMessage createMessage(Object event) throws Exception {
        MQMessage message = new MQMessage();
        String jsonPayload = objectMapper.writeValueAsString(event);
        message.writeString(jsonPayload);
        message.messageType = MQC.MQMT_DATAGRAM;
        message.format = MQC.MQFMT_STRING;
        return message;
    }
    
    private EventMessage createEventMessage(MQMessage message, String queueName) throws Exception {
        String jsonPayload = message.readStringOfByteLength(message.getMessageLength());
        Object payload = objectMapper.readValue(jsonPayload, Object.class);
        
        return EventMessage.builder()
            .messageId(message.messageId)
            .correlationId(message.correlationId)
            .queueName(queueName)
            .payload(payload)
            .headers(extractHeaders(message))
            .timestamp(LocalDateTime.now())
            .deliveryCount(message.persistence)
            .build();
    }
    
    private MQQueue getQueue(String queueName) throws MQException {
        return queues.computeIfAbsent(queueName, name -> {
            try {
                return queueManager.accessQueue(name, MQC.MQOO_OUTPUT | MQC.MQOO_INPUT_AS_Q_DEF);
            } catch (MQException e) {
                throw new RuntimeException("Failed to access queue: " + name, e);
            }
        });
    }
    
    private RetryTemplate createRetryTemplate() {
        RetryTemplate template = new RetryTemplate();
        template.setRetryPolicy(new SimpleRetryPolicy(3, Collections.singletonMap(Exception.class, true)));
        template.setBackOffPolicy(new ExponentialBackOffPolicy());
        return template;
    }
}
```

## Queue Configuration

### Queue Definitions

**Queue Configuration**:
```yaml
ibm-mq:
  connection:
    host: "mq-server.company.com"
    port: 1414
    channel: "SYSTEM.DEF.SVRCONN"
    queue-manager: "QMGR1"
    username: "${MQ_USERNAME}"
    password: "${MQ_PASSWORD}"
    connection-timeout: 30000
    read-timeout: 30000
    thread-pool-size: 20
    
  queues:
    lifecycle-events: "LIFECYCLE.EVENTS"
    position-updates: "POSITION.UPDATES"
    cashflows-generated: "CASHFLOWS.GENERATED"
    settlement-instructions: "SETTLEMENT.INSTRUCTIONS"
    exceptions: "EXCEPTIONS.QUEUE"
    dead-letter: "DEAD.LETTER.QUEUE"
    
  queue-properties:
    lifecycle-events:
      max-depth: 100000
      max-message-length: 1048576
      persistence: true
      priority: 5
      
    position-updates:
      max-depth: 500000
      max-message-length: 2097152
      persistence: true
      priority: 7
      
    cashflows-generated:
      max-depth: 1000000
      max-message-length: 1048576
      persistence: true
      priority: 6
      
    settlement-instructions:
      max-depth: 200000
      max-message-length: 524288
      persistence: true
      priority: 8
      
    exceptions:
      max-depth: 50000
      max-message-length: 1048576
      persistence: true
      priority: 1
      
    dead-letter:
      max-depth: 10000
      max-message-length: 1048576
      persistence: true
      priority: 0
```

### Queue Manager Configuration

**MQ Configuration Class**:
```java
@Configuration
@ConfigurationProperties(prefix = "ibm-mq")
@Data
public class MQConfiguration {
    private Connection connection = new Connection();
    private Map<String, String> queues = new HashMap<>();
    private Map<String, QueueProperties> queueProperties = new HashMap<>();
    
    @Data
    public static class Connection {
        private String host;
        private int port;
        private String channel;
        private String queueManager;
        private String username;
        private String password;
        private int connectionTimeout = 30000;
        private int readTimeout = 30000;
        private int threadPoolSize = 20;
    }
    
    @Data
    public static class QueueProperties {
        private int maxDepth = 100000;
        private int maxMessageLength = 1048576;
        private boolean persistence = true;
        private int priority = 5;
    }
}
```

## Message Serialization

### Event Serialization

**Event Serializer**:
```java
@Component
public class EventSerializer {
    private final ObjectMapper objectMapper;
    
    public EventSerializer() {
        this.objectMapper = new ObjectMapper();
        this.objectMapper.registerModule(new JavaTimeModule());
        this.objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        this.objectMapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);
    }
    
    public String serialize(Object event) {
        try {
            return objectMapper.writeValueAsString(event);
        } catch (JsonProcessingException e) {
            throw new EventSerializationException("Failed to serialize event", e);
        }
    }
    
    public <T> T deserialize(String json, Class<T> eventType) {
        try {
            return objectMapper.readValue(json, eventType);
        } catch (JsonProcessingException e) {
            throw new EventSerializationException("Failed to deserialize event", e);
        }
    }
    
    public <T> T deserialize(String json, TypeReference<T> typeReference) {
        try {
            return objectMapper.readValue(json, typeReference);
        } catch (JsonProcessingException e) {
            throw new EventSerializationException("Failed to deserialize event", e);
        }
    }
}
```

### Message Headers

**Message Header Management**:
```java
@Component
public class MessageHeaderManager {
    
    public Map<String, Object> createHeaders(String eventType, String sourceService) {
        Map<String, Object> headers = new HashMap<>();
        headers.put("event_type", eventType);
        headers.put("source_service", sourceService);
        headers.put("timestamp", LocalDateTime.now().toString());
        headers.put("message_id", UUID.randomUUID().toString());
        headers.put("version", "1.0");
        return headers;
    }
    
    public Map<String, Object> extractHeaders(MQMessage message) {
        Map<String, Object> headers = new HashMap<>();
        headers.put("message_id", message.messageId);
        headers.put("correlation_id", message.correlationId);
        headers.put("reply_to_queue", message.replyToQueueName);
        headers.put("message_type", message.messageType);
        headers.put("format", message.format);
        headers.put("priority", message.priority);
        headers.put("persistence", message.persistence);
        return headers;
    }
}
```

## Error Handling and Resilience

### Dead Letter Queue Handling

**Dead Letter Queue Manager**:
```java
@Component
@Slf4j
public class DeadLetterQueueManager {
    
    private final EventPublisher eventPublisher;
    private final EventSerializer eventSerializer;
    private final DeadLetterQueueRepository repository;
    
    public void handleDeadLetter(EventMessage message, Exception error) {
        try {
            DeadLetterEntry entry = DeadLetterEntry.builder()
                .messageId(message.getMessageId())
                .correlationId(message.getCorrelationId())
                .queueName(message.getQueueName())
                .payload(eventSerializer.serialize(message.getPayload()))
                .headers(message.getHeaders())
                .errorMessage(error.getMessage())
                .errorStackTrace(getStackTrace(error))
                .timestamp(LocalDateTime.now())
                .retryCount(0)
                .status(DeadLetterStatus.PENDING)
                .build();
            
            repository.save(entry);
            
            // Publish to dead letter queue for monitoring
            eventPublisher.publishToDeadLetterQueue(
                message.getQueueName(), 
                message.getPayload(), 
                error.getMessage()
            );
            
            log.error("Message sent to dead letter queue: {}", message.getMessageId());
        } catch (Exception e) {
            log.error("Failed to handle dead letter message: {}", message.getMessageId(), e);
        }
    }
    
    @Scheduled(fixedRate = 300000) // 5 minutes
    public void retryDeadLetterMessages() {
        List<DeadLetterEntry> pendingEntries = repository.findByStatusAndRetryCountLessThan(
            DeadLetterStatus.PENDING, 3
        );
        
        for (DeadLetterEntry entry : pendingEntries) {
            try {
                Object payload = eventSerializer.deserialize(entry.getPayload(), Object.class);
                EventMessage message = EventMessage.builder()
                    .messageId(entry.getMessageId())
                    .correlationId(entry.getCorrelationId())
                    .queueName(entry.getQueueName())
                    .payload(payload)
                    .headers(entry.getHeaders())
                    .build();
                
                // Retry the message
                eventPublisher.publish(entry.getQueueName(), payload);
                
                // Update retry count
                entry.setRetryCount(entry.getRetryCount() + 1);
                entry.setStatus(DeadLetterStatus.RETRIED);
                repository.save(entry);
                
                log.info("Retried dead letter message: {}", entry.getMessageId());
            } catch (Exception e) {
                log.error("Failed to retry dead letter message: {}", entry.getMessageId(), e);
                entry.setRetryCount(entry.getRetryCount() + 1);
                if (entry.getRetryCount() >= 3) {
                    entry.setStatus(DeadLetterStatus.FAILED);
                }
                repository.save(entry);
            }
        }
    }
}
```

### Circuit Breaker Pattern

**MQ Circuit Breaker**:
```java
@Component
public class MQCircuitBreaker {
    
    private final CircuitBreaker circuitBreaker;
    private final EventPublisher eventPublisher;
    
    public MQCircuitBreaker(EventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
        this.circuitBreaker = CircuitBreaker.ofDefaults("mq-circuit-breaker")
            .toBuilder()
            .failureRateThreshold(50)
            .waitDurationInOpenState(Duration.ofSeconds(30))
            .slidingWindowSize(10)
            .minimumNumberOfCalls(5)
            .build();
    }
    
    public void publishWithCircuitBreaker(String queueName, Object event) {
        circuitBreaker.executeSupplier(() -> {
            eventPublisher.publish(queueName, event);
            return null;
        });
    }
    
    public CompletableFuture<Void> publishAsyncWithCircuitBreaker(String queueName, Object event) {
        return CompletableFuture.supplyAsync(() -> {
            circuitBreaker.executeSupplier(() -> {
                eventPublisher.publish(queueName, event);
                return null;
            });
            return null;
        });
    }
}
```

## Monitoring and Metrics

### MQ Metrics

**MQ Metrics Collector**:
```java
@Component
public class MQMetricsCollector {
    
    private final MeterRegistry meterRegistry;
    private final Map<String, Counter> publishCounters;
    private final Map<String, Timer> publishTimers;
    private final Map<String, Gauge> queueDepthGauges;
    
    public MQMetricsCollector(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.publishCounters = new ConcurrentHashMap<>();
        this.publishTimers = new ConcurrentHashMap<>();
        this.queueDepthGauges = new ConcurrentHashMap<>();
    }
    
    public void recordPublish(String queueName, Duration duration) {
        Counter counter = publishCounters.computeIfAbsent(queueName, 
            name -> Counter.builder("mq.publish.count")
                .tag("queue", name)
                .register(meterRegistry)
        );
        counter.increment();
        
        Timer timer = publishTimers.computeIfAbsent(queueName,
            name -> Timer.builder("mq.publish.duration")
                .tag("queue", name)
                .register(meterRegistry)
        );
        timer.record(duration);
    }
    
    public void recordQueueDepth(String queueName, int depth) {
        Gauge gauge = queueDepthGauges.computeIfAbsent(queueName,
            name -> Gauge.builder("mq.queue.depth")
                .tag("queue", name)
                .register(meterRegistry, this, obj -> getQueueDepth(name))
        );
    }
    
    private int getQueueDepth(String queueName) {
        // Implementation to get actual queue depth from MQ
        return 0;
    }
}
```

### Health Checks

**MQ Health Indicator**:
```java
@Component
public class MQHealthIndicator implements HealthIndicator {
    
    private final IBMQueueManager queueManager;
    private final MQConfiguration config;
    
    @Override
    public Health health() {
        try {
            // Test queue connection
            MQQueue queue = queueManager.getQueue("SYSTEM.DEFAULT.LOCAL.QUEUE");
            queue.close();
            
            return Health.up()
                .withDetail("mq", "IBM MQ")
                .withDetail("queue_manager", config.getConnection().getQueueManager())
                .withDetail("host", config.getConnection().getHost())
                .withDetail("port", config.getConnection().getPort())
                .withDetail("connection", "Active")
                .build();
        } catch (Exception e) {
            return Health.down()
                .withDetail("mq", "IBM MQ")
                .withDetail("queue_manager", config.getConnection().getQueueManager())
                .withDetail("host", config.getConnection().getHost())
                .withDetail("port", config.getConnection().getPort())
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}
```

## Performance Optimization

### Connection Pooling

**MQ Connection Pool**:
```java
@Component
public class MQConnectionPool {
    
    private final BlockingQueue<MQQueueManager> connectionPool;
    private final MQConfiguration config;
    private final int poolSize;
    
    public MQConnectionPool(MQConfiguration config) {
        this.config = config;
        this.poolSize = config.getConnection().getThreadPoolSize();
        this.connectionPool = new LinkedBlockingQueue<>(poolSize);
        
        initializePool();
    }
    
    private void initializePool() {
        for (int i = 0; i < poolSize; i++) {
            try {
                MQQueueManager queueManager = new MQQueueManager(
                    config.getConnection().getQueueManager(),
                    config.getConnection().getChannelName(),
                    config.getConnection().getConnectionName(),
                    config.getConnection().getUsername(),
                    config.getConnection().getPassword()
                );
                connectionPool.offer(queueManager);
            } catch (MQException e) {
                log.error("Failed to create MQ connection", e);
            }
        }
    }
    
    public MQQueueManager borrowConnection() throws InterruptedException {
        return connectionPool.take();
    }
    
    public void returnConnection(MQQueueManager connection) {
        connectionPool.offer(connection);
    }
}
```

### Batch Processing

**Batch Message Processor**:
```java
@Component
public class BatchMessageProcessor {
    
    private final EventPublisher eventPublisher;
    private final EventSerializer eventSerializer;
    private final int batchSize;
    private final Duration batchTimeout;
    
    public BatchMessageProcessor(EventPublisher eventPublisher, EventSerializer eventSerializer) {
        this.eventPublisher = eventPublisher;
        this.eventSerializer = eventSerializer;
        this.batchSize = 100;
        this.batchTimeout = Duration.ofSeconds(5);
    }
    
    public void processBatch(String queueName, List<Object> events) {
        if (events.size() <= batchSize) {
            // Process as single batch
            processSingleBatch(queueName, events);
        } else {
            // Split into multiple batches
            List<List<Object>> batches = Lists.partition(events, batchSize);
            batches.forEach(batch -> processSingleBatch(queueName, batch));
        }
    }
    
    private void processSingleBatch(String queueName, List<Object> events) {
        try {
            String batchPayload = eventSerializer.serialize(events);
            eventPublisher.publish(queueName, batchPayload);
        } catch (Exception e) {
            log.error("Failed to process batch for queue: {}", queueName, e);
            // Fallback to individual message processing
            events.forEach(event -> eventPublisher.publish(queueName, event));
        }
    }
}
```
