# Database Design Specification

## Overview

This document outlines the database design for the Swap Life Cycle Management Service, including the Trade Database, Event Store, and Cashflow Database schemas.

## Database Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    Database Architecture                        │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │
│  │   Trade     │  │    Event    │  │  Cashflow   │  │ Reference   │ │
│  │  Database   │  │    Store    │  │  Database   │  │   Data      │ │
│  │ (MS SQL)    │  │ (MS SQL)    │  │ (MS SQL)    │  │   Cache     │ │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

## Trade Database Schema

### Core Domain Tables

**Party Table**:
```sql
CREATE TABLE Party (
    party_id VARCHAR(50) PRIMARY KEY,
    party_name VARCHAR(200) NOT NULL,
    party_type VARCHAR(20) NOT NULL CHECK (party_type IN ('BANK','FUND','CORPORATION','INDIVIDUAL','GOVERNMENT','OTHER')),
    lei_code CHAR(20) UNIQUE,
    party_identifiers NVARCHAR(MAX), -- JSON
    country_of_incorporation CHAR(2),
    address NVARCHAR(MAX), -- JSON
    contact_information NVARCHAR(MAX), -- JSON
    regulatory_status NVARCHAR(MAX), -- JSON
    credit_rating VARCHAR(10),
    is_active BIT DEFAULT 1,
    created_date DATE NOT NULL DEFAULT CAST(GETDATE() AS DATE),
    last_updated DATETIME2 DEFAULT GETDATE()
);

CREATE INDEX IX_Party_Type ON Party(party_type);
CREATE INDEX IX_Party_Active ON Party(is_active);
CREATE INDEX IX_Party_Country ON Party(country_of_incorporation);
```

**Underlier Table**:
```sql
CREATE TABLE Underlier (
    underlier_id VARCHAR(50) PRIMARY KEY,
    asset_type VARCHAR(20) NOT NULL CHECK (asset_type IN ('SINGLE_NAME','INDEX','BASKET')),
    primary_identifier VARCHAR(50) NOT NULL,
    identifier_type VARCHAR(20) NOT NULL CHECK (identifier_type IN ('ISIN','CUSIP','RIC','BLOOMBERG','INTERNAL')),
    secondary_identifiers NVARCHAR(MAX), -- JSON
    asset_name VARCHAR(200) NOT NULL,
    asset_description NVARCHAR(MAX),
    currency CHAR(3) NOT NULL,
    exchange VARCHAR(50),
    country CHAR(2),
    sector VARCHAR(100),
    is_active BIT DEFAULT 1,
    created_date DATE NOT NULL DEFAULT CAST(GETDATE() AS DATE),
    last_updated DATETIME2 DEFAULT GETDATE()
);

CREATE INDEX IX_Underlier_AssetType ON Underlier(asset_type);
CREATE INDEX IX_Underlier_Identifier ON Underlier(primary_identifier, identifier_type);
CREATE INDEX IX_Underlier_Currency ON Underlier(currency);
CREATE INDEX IX_Underlier_Active ON Underlier(is_active);
```

**BasketComponent Table**:
```sql
CREATE TABLE BasketComponent (
    component_id VARCHAR(50) PRIMARY KEY,
    basket_id VARCHAR(50) NOT NULL,
    component_underlier_id VARCHAR(50) NOT NULL,
    weight DECIMAL(10,6) NOT NULL CHECK (weight > 0 AND weight <= 1),
    shares DECIMAL(18,6),
    effective_date DATE NOT NULL,
    termination_date DATE,
    created_date DATE NOT NULL DEFAULT CAST(GETDATE() AS DATE),
    last_updated DATETIME2 DEFAULT GETDATE(),
    
    CONSTRAINT fk_basket_component_basket FOREIGN KEY (basket_id) REFERENCES Underlier(underlier_id),
    CONSTRAINT fk_basket_component_underlier FOREIGN KEY (component_underlier_id) REFERENCES Underlier(underlier_id),
    CONSTRAINT ck_basket_component_dates CHECK (termination_date IS NULL OR termination_date >= effective_date),
    CONSTRAINT ck_basket_component_no_self_reference CHECK (basket_id != component_underlier_id)
);

CREATE INDEX IX_BasketComponent_Basket ON BasketComponent(basket_id);
CREATE INDEX IX_BasketComponent_Underlier ON BasketComponent(component_underlier_id);
CREATE INDEX IX_BasketComponent_EffectiveDate ON BasketComponent(effective_date);
```

**TradableProduct Table**:
```sql
CREATE TABLE TradableProduct (
    product_id VARCHAR(50) PRIMARY KEY,
    product_type VARCHAR(50) NOT NULL CHECK (product_type IN ('EQUITY_SWAP_PRICE_RETURN','EQUITY_SWAP_TOTAL_RETURN','EQUITY_SWAP_VARIANCE','EQUITY_SWAP_VOLATILITY')),
    product_name VARCHAR(200),
    asset_class VARCHAR(50) DEFAULT 'EQUITY',
    sub_asset_class VARCHAR(50) DEFAULT 'SWAP',
    version INTEGER DEFAULT 1 CHECK (version > 0),
    is_active BIT DEFAULT 1,
    created_date DATE NOT NULL DEFAULT CAST(GETDATE() AS DATE),
    created_by VARCHAR(100)
);

CREATE INDEX IX_TradableProduct_Type ON TradableProduct(product_type);
CREATE INDEX IX_TradableProduct_Active ON TradableProduct(is_active);
```

**EconomicTerms Table**:
```sql
CREATE TABLE EconomicTerms (
    economic_terms_id VARCHAR(50) PRIMARY KEY,
    product_id VARCHAR(50) NOT NULL,
    effective_date DATE NOT NULL,
    termination_date DATE,
    calculation_agent_id VARCHAR(50),
    business_day_convention VARCHAR(30),
    business_centers NVARCHAR(MAX), -- JSON
    extraordinary_events NVARCHAR(MAX), -- JSON
    version INTEGER DEFAULT 1 CHECK (version > 0),
    created_date DATE NOT NULL DEFAULT CAST(GETDATE() AS DATE),
    last_updated DATETIME2 DEFAULT GETDATE(),
    
    CONSTRAINT fk_economic_terms_product FOREIGN KEY (product_id) REFERENCES TradableProduct(product_id),
    CONSTRAINT fk_economic_terms_calc_agent FOREIGN KEY (calculation_agent_id) REFERENCES Party(party_id),
    CONSTRAINT ck_economic_terms_dates CHECK (termination_date IS NULL OR termination_date >= effective_date)
);

CREATE INDEX IX_EconomicTerms_Product ON EconomicTerms(product_id);
CREATE INDEX IX_EconomicTerms_EffectiveDate ON EconomicTerms(effective_date);
CREATE INDEX IX_EconomicTerms_TerminationDate ON EconomicTerms(termination_date);
```

**Payout Table (Flattened)**:
```sql
CREATE TABLE Payout (
    payout_id VARCHAR(50) PRIMARY KEY,
    economic_terms_id VARCHAR(50) NOT NULL,
    payout_type VARCHAR(20) NOT NULL CHECK (payout_type IN ('PERFORMANCE','INTEREST_RATE','DIVIDEND','FIXED')),
    payer_party_id VARCHAR(50) NOT NULL,
    receiver_party_id VARCHAR(50) NOT NULL,
    payment_frequency VARCHAR(20),
    day_count_fraction VARCHAR(10),
    currency CHAR(3) NOT NULL,
    settlement_currency CHAR(3),
    fx_reset_required BIT DEFAULT 0,
    fx_reset_frequency VARCHAR(20),
    fx_rate_source VARCHAR(100),
    fx_fixing_time TIME,
    
    -- Interest leg fields
    rate_type VARCHAR(20),
    fixed_rate DECIMAL(8,4),
    floating_rate_index VARCHAR(50),
    spread DECIMAL(8,4),
    reset_frequency VARCHAR(20),
    compounding_method VARCHAR(20),
    notional_amount DECIMAL(18,2),
    notional_currency CHAR(3),
    
    -- Performance leg fields
    return_type VARCHAR(20),
    initial_price DECIMAL(18,6),
    initial_price_date DATE,
    observation_start_date DATE,
    observation_end_date DATE,
    valuation_time TIME,
    
    -- Dividend leg fields
    dividend_treatment VARCHAR(20),
    dividend_percentage DECIMAL(5,2),
    ex_dividend_treatment VARCHAR(20),
    withholding_tax_rate DECIMAL(5,4),
    minimum_dividend_amount DECIMAL(18,2),
    maximum_dividend_amount DECIMAL(18,2),
    dividend_currency CHAR(3),
    payment_delay_days INTEGER,
    
    created_date DATE NOT NULL DEFAULT CAST(GETDATE() AS DATE),
    last_updated DATETIME2 DEFAULT GETDATE(),
    
    CONSTRAINT fk_payout_economic_terms FOREIGN KEY (economic_terms_id) REFERENCES EconomicTerms(economic_terms_id),
    CONSTRAINT fk_payout_payer FOREIGN KEY (payer_party_id) REFERENCES Party(party_id),
    CONSTRAINT fk_payout_receiver FOREIGN KEY (receiver_party_id) REFERENCES Party(party_id),
    CONSTRAINT ck_payout_different_parties CHECK (payer_party_id != receiver_party_id)
);

CREATE INDEX IX_Payout_EconomicTerms ON Payout(economic_terms_id);
CREATE INDEX IX_Payout_Type ON Payout(payout_type);
CREATE INDEX IX_Payout_Payer ON Payout(payer_party_id);
CREATE INDEX IX_Payout_Receiver ON Payout(receiver_party_id);
CREATE INDEX IX_Payout_Currency ON Payout(currency);
```

**Trade Table**:
```sql
CREATE TABLE Trade (
    trade_id VARCHAR(50) PRIMARY KEY,
    product_id VARCHAR(50) NOT NULL,
    trade_date DATE NOT NULL,
    trade_time DATETIME2,
    status VARCHAR(20) DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE','TERMINATED','SUSPENDED')),
    master_agreement_id VARCHAR(50),
    confirmation_method VARCHAR(20),
    created_timestamp DATETIME2 DEFAULT GETDATE(),
    updated_timestamp DATETIME2 DEFAULT GETDATE(),
    
    CONSTRAINT fk_trade_product FOREIGN KEY (product_id) REFERENCES TradableProduct(product_id),
    CONSTRAINT ck_trade_date_not_future CHECK (trade_date <= CAST(GETDATE() AS DATE))
);

CREATE INDEX IX_Trade_Product ON Trade(product_id);
CREATE INDEX IX_Trade_Date ON Trade(trade_date);
CREATE INDEX IX_Trade_Status ON Trade(status);
CREATE INDEX IX_Trade_CreatedTimestamp ON Trade(created_timestamp);
```

## Event Store Schema

**LifecycleEvent Table**:
```sql
CREATE TABLE LifecycleEvent (
    event_id VARCHAR(50) PRIMARY KEY,
    trade_id VARCHAR(50) NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    event_data NVARCHAR(MAX) NOT NULL, -- JSON serialized event
    sequence_number BIGINT NOT NULL,
    timestamp DATETIME2 NOT NULL,
    source_blotter_id VARCHAR(50),
    processing_timestamp DATETIME2 DEFAULT GETDATE(),
    user_id VARCHAR(100),
    reason_code VARCHAR(50),
    previous_aggregate_hash VARCHAR(64),
    
    CONSTRAINT fk_event_trade FOREIGN KEY (trade_id) REFERENCES Trade(trade_id)
);

CREATE INDEX IX_LifecycleEvent_TradeId ON LifecycleEvent(trade_id);
CREATE INDEX IX_LifecycleEvent_Type ON LifecycleEvent(event_type);
CREATE INDEX IX_LifecycleEvent_Sequence ON LifecycleEvent(trade_id, sequence_number);
CREATE INDEX IX_LifecycleEvent_Timestamp ON LifecycleEvent(timestamp);
CREATE INDEX IX_LifecycleEvent_SourceBlotter ON LifecycleEvent(source_blotter_id);
```

**TradeAggregate Table**:
```sql
CREATE TABLE TradeAggregate (
    trade_id VARCHAR(50) PRIMARY KEY,
    version INTEGER NOT NULL,
    status VARCHAR(20) NOT NULL,
    product_id VARCHAR(50) NOT NULL,
    trade_date DATE NOT NULL,
    aggregate_data NVARCHAR(MAX) NOT NULL, -- JSON serialized aggregate
    aggregate_hash VARCHAR(64) NOT NULL,
    last_event_id VARCHAR(50) NOT NULL,
    created_timestamp DATETIME2 DEFAULT GETDATE(),
    updated_timestamp DATETIME2 DEFAULT GETDATE(),
    
    CONSTRAINT fk_aggregate_trade FOREIGN KEY (trade_id) REFERENCES Trade(trade_id),
    CONSTRAINT fk_aggregate_product FOREIGN KEY (product_id) REFERENCES TradableProduct(product_id),
    CONSTRAINT fk_aggregate_last_event FOREIGN KEY (last_event_id) REFERENCES LifecycleEvent(event_id),
    CONSTRAINT ck_aggregate_version CHECK (version > 0)
);

CREATE INDEX IX_TradeAggregate_Version ON TradeAggregate(trade_id, version);
CREATE INDEX IX_TradeAggregate_Status ON TradeAggregate(status);
CREATE INDEX IX_TradeAggregate_UpdatedTimestamp ON TradeAggregate(updated_timestamp);
```

**EventSnapshot Table**:
```sql
CREATE TABLE EventSnapshot (
    snapshot_id VARCHAR(50) PRIMARY KEY,
    trade_id VARCHAR(50) NOT NULL,
    snapshot_version INTEGER NOT NULL,
    snapshot_data NVARCHAR(MAX) NOT NULL, -- JSON serialized snapshot
    snapshot_hash VARCHAR(64) NOT NULL,
    last_event_id VARCHAR(50) NOT NULL,
    created_timestamp DATETIME2 DEFAULT GETDATE(),
    
    CONSTRAINT fk_snapshot_trade FOREIGN KEY (trade_id) REFERENCES Trade(trade_id),
    CONSTRAINT fk_snapshot_last_event FOREIGN KEY (last_event_id) REFERENCES LifecycleEvent(event_id),
    CONSTRAINT ck_snapshot_version CHECK (snapshot_version > 0)
);

CREATE INDEX IX_EventSnapshot_TradeId ON EventSnapshot(trade_id);
CREATE INDEX IX_EventSnapshot_Version ON EventSnapshot(trade_id, snapshot_version);
CREATE INDEX IX_EventSnapshot_CreatedTimestamp ON EventSnapshot(created_timestamp);
```

## Cashflow Database Schema

**Cashflow Table**:
```sql
CREATE TABLE Cashflow (
    cashflow_id VARCHAR(50) PRIMARY KEY,
    trade_id VARCHAR(50) NOT NULL,
    position_id VARCHAR(50) NOT NULL,
    lot_id VARCHAR(50),
    cashflow_type VARCHAR(20) NOT NULL CHECK (cashflow_type IN ('ACCRUAL','INTEREST','FEE','DIVIDEND','PRINCIPAL','RESET')),
    payer_party_id VARCHAR(50) NOT NULL,
    receiver_party_id VARCHAR(50) NOT NULL,
    currency CHAR(3) NOT NULL,
    amount DECIMAL(18,2) NOT NULL,
    settlement_date DATE NOT NULL,
    payment_type VARCHAR(20) NOT NULL CHECK (payment_type IN ('ACCRUAL','PRINCIPAL','DIVIDEND','FEE')),
    origin_event_id VARCHAR(50) NOT NULL,
    revision_number INTEGER DEFAULT 1,
    is_cancelled BIT DEFAULT 0,
    cancellation_reason VARCHAR(100),
    created_timestamp DATETIME2 DEFAULT GETDATE(),
    updated_timestamp DATETIME2 DEFAULT GETDATE(),
    
    CONSTRAINT fk_cashflow_trade FOREIGN KEY (trade_id) REFERENCES Trade(trade_id),
    CONSTRAINT fk_cashflow_payer FOREIGN KEY (payer_party_id) REFERENCES Party(party_id),
    CONSTRAINT fk_cashflow_receiver FOREIGN KEY (receiver_party_id) REFERENCES Party(party_id),
    CONSTRAINT fk_cashflow_origin_event FOREIGN KEY (origin_event_id) REFERENCES LifecycleEvent(event_id),
    CONSTRAINT ck_cashflow_revision CHECK (revision_number > 0),
    CONSTRAINT ck_cashflow_amount CHECK (amount != 0)
);

CREATE INDEX IX_Cashflow_TradeId ON Cashflow(trade_id);
CREATE INDEX IX_Cashflow_PositionId ON Cashflow(position_id);
CREATE INDEX IX_Cashflow_Type ON Cashflow(cashflow_type);
CREATE INDEX IX_Cashflow_SettlementDate ON Cashflow(settlement_date);
CREATE INDEX IX_Cashflow_Payer ON Cashflow(payer_party_id);
CREATE INDEX IX_Cashflow_Receiver ON Cashflow(receiver_party_id);
CREATE INDEX IX_Cashflow_OriginEvent ON Cashflow(origin_event_id);
CREATE INDEX IX_Cashflow_Revision ON Cashflow(trade_id, revision_number);
CREATE INDEX IX_Cashflow_Cancelled ON Cashflow(is_cancelled);
```

**CashflowRevision Table**:
```sql
CREATE TABLE CashflowRevision (
    revision_id VARCHAR(50) PRIMARY KEY,
    trade_id VARCHAR(50) NOT NULL,
    revision_number INTEGER NOT NULL,
    origin_event_id VARCHAR(50) NOT NULL,
    revision_type VARCHAR(20) NOT NULL CHECK (revision_type IN ('GENERATION','AMENDMENT','CANCELLATION')),
    affected_cashflow_ids NVARCHAR(MAX), -- JSON array of cashflow IDs
    revision_data NVARCHAR(MAX), -- JSON serialized revision details
    created_timestamp DATETIME2 DEFAULT GETDATE(),
    
    CONSTRAINT fk_revision_trade FOREIGN KEY (trade_id) REFERENCES Trade(trade_id),
    CONSTRAINT fk_revision_origin_event FOREIGN KEY (origin_event_id) REFERENCES LifecycleEvent(event_id),
    CONSTRAINT ck_revision_number CHECK (revision_number > 0)
);

CREATE INDEX IX_CashflowRevision_TradeId ON CashflowRevision(trade_id);
CREATE INDEX IX_CashflowRevision_Number ON CashflowRevision(trade_id, revision_number);
CREATE INDEX IX_CashflowRevision_OriginEvent ON CashflowRevision(origin_event_id);
CREATE INDEX IX_CashflowRevision_Type ON CashflowRevision(revision_type);
```

**SettlementInstruction Table**:
```sql
CREATE TABLE SettlementInstruction (
    instruction_id VARCHAR(50) PRIMARY KEY,
    cashflow_id VARCHAR(50) NOT NULL,
    trade_id VARCHAR(50) NOT NULL,
    payer_party_id VARCHAR(50) NOT NULL,
    receiver_party_id VARCHAR(50) NOT NULL,
    currency CHAR(3) NOT NULL,
    amount DECIMAL(18,2) NOT NULL,
    settlement_date DATE NOT NULL,
    payment_type VARCHAR(20) NOT NULL,
    status VARCHAR(20) DEFAULT 'READY' CHECK (status IN ('READY','SENT','CONFIRMED','REJECTED')),
    originating_event_id VARCHAR(50) NOT NULL,
    settlement_system_id VARCHAR(50),
    settlement_reference VARCHAR(100),
    created_timestamp DATETIME2 DEFAULT GETDATE(),
    sent_timestamp DATETIME2,
    confirmed_timestamp DATETIME2,
    
    CONSTRAINT fk_settlement_cashflow FOREIGN KEY (cashflow_id) REFERENCES Cashflow(cashflow_id),
    CONSTRAINT fk_settlement_trade FOREIGN KEY (trade_id) REFERENCES Trade(trade_id),
    CONSTRAINT fk_settlement_payer FOREIGN KEY (payer_party_id) REFERENCES Party(party_id),
    CONSTRAINT fk_settlement_receiver FOREIGN KEY (receiver_party_id) REFERENCES Party(party_id),
    CONSTRAINT fk_settlement_origin_event FOREIGN KEY (originating_event_id) REFERENCES LifecycleEvent(event_id)
);

CREATE INDEX IX_SettlementInstruction_CashflowId ON SettlementInstruction(cashflow_id);
CREATE INDEX IX_SettlementInstruction_TradeId ON SettlementInstruction(trade_id);
CREATE INDEX IX_SettlementInstruction_SettlementDate ON SettlementInstruction(settlement_date);
CREATE INDEX IX_SettlementInstruction_Status ON SettlementInstruction(status);
CREATE INDEX IX_SettlementInstruction_Payer ON SettlementInstruction(payer_party_id);
CREATE INDEX IX_SettlementInstruction_Receiver ON SettlementInstruction(receiver_party_id);
```

## Performance Optimization

### Partitioning Strategy

**Trade Table Partitioning**:
```sql
-- Partition by trade_date for better query performance
CREATE PARTITION FUNCTION PF_TradeDate (DATE)
AS RANGE RIGHT FOR VALUES ('2024-01-01', '2024-02-01', '2024-03-01', '2024-04-01', '2024-05-01', '2024-06-01');

CREATE PARTITION SCHEME PS_TradeDate
AS PARTITION PF_TradeDate
TO ('PRIMARY', 'PRIMARY', 'PRIMARY', 'PRIMARY', 'PRIMARY', 'PRIMARY', 'PRIMARY');

-- Apply partitioning to Trade table
ALTER TABLE Trade ADD CONSTRAINT PK_Trade_Partitioned PRIMARY KEY (trade_id, trade_date)
ON PS_TradeDate(trade_date);
```

**Cashflow Table Partitioning**:
```sql
-- Partition by settlement_date for better query performance
CREATE PARTITION FUNCTION PF_SettlementDate (DATE)
AS RANGE RIGHT FOR VALUES ('2024-01-01', '2024-02-01', '2024-03-01', '2024-04-01', '2024-05-01', '2024-06-01');

CREATE PARTITION SCHEME PS_SettlementDate
AS PARTITION PF_SettlementDate
TO ('PRIMARY', 'PRIMARY', 'PRIMARY', 'PRIMARY', 'PRIMARY', 'PRIMARY', 'PRIMARY');

-- Apply partitioning to Cashflow table
ALTER TABLE Cashflow ADD CONSTRAINT PK_Cashflow_Partitioned PRIMARY KEY (cashflow_id, settlement_date)
ON PS_SettlementDate(settlement_date);
```

### Indexing Strategy

**Composite Indexes for Common Queries**:
```sql
-- Trade queries by date range and status
CREATE INDEX IX_Trade_DateStatus ON Trade(trade_date, status);

-- Cashflow queries by trade and settlement date
CREATE INDEX IX_Cashflow_TradeSettlement ON Cashflow(trade_id, settlement_date);

-- Event queries by trade and sequence
CREATE INDEX IX_LifecycleEvent_TradeSequence ON LifecycleEvent(trade_id, sequence_number);

-- Settlement instruction queries by date and status
CREATE INDEX IX_SettlementInstruction_DateStatus ON SettlementInstruction(settlement_date, status);
```

### Connection Pooling Configuration

**HikariCP Configuration**:
```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      idle-timeout: 300000
      max-lifetime: 1200000
      connection-timeout: 30000
      validation-timeout: 5000
      leak-detection-threshold: 60000
      connection-test-query: "SELECT 1"
```

## Data Retention Policies

### Retention Configuration

**Event Store Retention**:
```sql
-- Create retention policy for old events
CREATE PROCEDURE SP_RetentionPolicy_Events
AS
BEGIN
    -- Archive events older than 7 years
    DELETE FROM LifecycleEvent 
    WHERE timestamp < DATEADD(YEAR, -7, GETDATE());
    
    -- Archive snapshots older than 5 years
    DELETE FROM EventSnapshot 
    WHERE created_timestamp < DATEADD(YEAR, -5, GETDATE());
END;
```

**Cashflow Retention**:
```sql
-- Create retention policy for old cashflows
CREATE PROCEDURE SP_RetentionPolicy_Cashflows
AS
BEGIN
    -- Archive cashflows older than 10 years
    DELETE FROM Cashflow 
    WHERE created_timestamp < DATEADD(YEAR, -10, GETDATE());
    
    -- Archive settlement instructions older than 7 years
    DELETE FROM SettlementInstruction 
    WHERE created_timestamp < DATEADD(YEAR, -7, GETDATE());
END;
```

## Backup and Recovery Strategy

### Backup Configuration

**Full Backup Schedule**:
```sql
-- Daily full backup
BACKUP DATABASE SwapLifecycleDB 
TO DISK = 'C:\Backups\SwapLifecycleDB_Full.bak'
WITH FORMAT, INIT, COMPRESSION;

-- Weekly differential backup
BACKUP DATABASE SwapLifecycleDB 
TO DISK = 'C:\Backups\SwapLifecycleDB_Diff.bak'
WITH DIFFERENTIAL, COMPRESSION;

-- Transaction log backup every 15 minutes
BACKUP LOG SwapLifecycleDB 
TO DISK = 'C:\Backups\SwapLifecycleDB_Log.trn'
WITH COMPRESSION;
```

### Recovery Testing

**Recovery Testing Procedure**:
```sql
-- Test restore procedure
RESTORE DATABASE SwapLifecycleDB_Test 
FROM DISK = 'C:\Backups\SwapLifecycleDB_Full.bak'
WITH REPLACE, MOVE 'SwapLifecycleDB' TO 'C:\Data\SwapLifecycleDB_Test.mdf',
     MOVE 'SwapLifecycleDB_Log' TO 'C:\Data\SwapLifecycleDB_Test_Log.ldf';
```
