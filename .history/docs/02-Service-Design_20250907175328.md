# Service Design Specification

## Service Decomposition

### 1. Blotter Ingest Service

**Purpose**: Accepts raw swap trade blotters and normalizes them into canonical lifecycle events.

**Responsibilities**:
- Accept raw blotters (JSON/CSV) from trade capture systems
- Validate and enrich trade data
- Normalize to canonical lifecycle events
- Publish to `lifecycle.events` queue
- Handle idempotency and duplicate detection

**Key Components**:
```java
@Service
public class BlotterIngestService {
    private final BlotterValidator validator;
    private final EventNormalizer normalizer;
    private final EventPublisher eventPublisher;
    private final IdempotencyService idempotencyService;
}
```

**Input Events**:
- `NewTrade`: Initial trade creation
- `Amendment`: Trade modifications
- `PartialUnwind`: Partial position reductions
- `Termination`: Complete trade termination
- `FixingPublished`: Market data updates

### 2. Position Management Service

**Purpose**: Maintains canonical trade state and position aggregates using event sourcing.

**Responsibilities**:
- Apply lifecycle events to trade aggregates
- Maintain position ledger (lots) with versioning
- Generate enriched position updates
- Provide deterministic state rebuilds
- Handle optimistic concurrency control

**Key Components**:
```java
@Service
public class PositionManagementService {
    private final TradeAggregateRepository repository;
    private final EventStore eventStore;
    private final PositionCalculator calculator;
    private final EventPublisher eventPublisher;
}
```

**Aggregate Model**:
```java
public class TradeAggregate {
    private String tradeId;
    private Integer version;
    private TradeStatus status;
    private List<Position> positions;
    private List<LifecycleEvent> uncommittedEvents;
    
    public void apply(LifecycleEvent event);
    public TradeAggregate rebuildFromEvents(List<LifecycleEvent> events);
}
```

### 3. Cashflow Management Service

**Purpose**: Deterministically generates cashflows from position updates with parallel processing.

**Responsibilities**:
- Process position updates in parallel
- Generate cashflow schedules (accruals, interest, fees, dividends, principal)
- Handle fixings/resets and recompute affected cashflows
- Persist cashflows to database
- Publish settlement-eligible cashflows

**Key Components**:
```java
@Service
public class CashflowManagementService {
    private final CashflowEngine engine;
    private final ParallelProcessor processor;
    private final CashflowRepository repository;
    private final SettlementPublisher settlementPublisher;
    private final ReferenceDataService referenceDataService;
}
```

**Parallel Processing Strategy**:
```java
@Component
public class ParallelProcessor {
    private final ThreadPoolExecutor tradeProcessor;
    private final ThreadPoolExecutor positionProcessor;
    
    public CompletableFuture<Void> processTrades(List<Trade> trades) {
        return CompletableFuture.allOf(
            trades.stream()
                .map(this::processTradeAsync)
                .toArray(CompletableFuture[]::new)
        );
    }
    
    private CompletableFuture<Void> processTradeAsync(Trade trade) {
        return CompletableFuture.allOf(
            trade.getPositions().stream()
                .map(position -> processPositionAsync(position))
                .toArray(CompletableFuture[]::new)
        );
    }
}
```

### 4. Reference Data Proxy Service

**Purpose**: Provides pluggable reference data implementation with mock data for development.

**Responsibilities**:
- Provide interface for reference data access
- Implement mock data for development/testing
- Cache reference data for performance
- Support seamless replacement with real implementation

**Key Components**:
```java
public interface ReferenceDataService {
    CompletableFuture<InterestRateCurve> getInterestRateCurve(String curveId, LocalDate date);
    CompletableFuture<Fixing> getFixing(String indexId, LocalDate date);
    CompletableFuture<Calendar> getBusinessCalendar(String calendarId);
    CompletableFuture<Party> getParty(String partyId);
}

@Service
public class MockReferenceDataService implements ReferenceDataService {
    // Mock implementation for development
}

@Service
public class RealReferenceDataService implements ReferenceDataService {
    // Real implementation when available
}
```

## Event Model Design

### Core Events
```java
public abstract class LifecycleEvent {
    private String eventId;
    private String tradeId;
    private LocalDateTime timestamp;
    private String sourceBlotterId;
    private Map<String, Object> metadata;
}

public class NewTradeEvent extends LifecycleEvent {
    private String productId;
    private String economicTermsId;
    private List<Party> parties;
    private List<Lot> lots;
    private LocalDateTime tradeTimestamp;
}

public class AmendmentEvent extends LifecycleEvent {
    private String amendmentId;
    private Map<String, Object> changedFields;
    private LocalDate effectiveDate;
    private List<Lot> revisedLots;
}

public class PartialUnwindEvent extends LifecycleEvent {
    private String unwindId;
    private List<String> lotsToRemove;
    private BigDecimal notionalReduction;
}

public class TerminationEvent extends LifecycleEvent {
    private String terminationId;
    private LocalDate terminationDate;
    private List<Cashflow> terminationCashflows;
}

public class FixingPublishedEvent extends LifecycleEvent {
    private String indexId;
    private LocalDate fixingDate;
    private LocalTime fixingTime;
    private BigDecimal fixingValue;
}
```

## Data Model Design

### Trade Aggregate Schema
```sql
CREATE TABLE TradeAggregate (
    trade_id VARCHAR(50) PRIMARY KEY,
    version INTEGER NOT NULL,
    status VARCHAR(20) NOT NULL,
    product_id VARCHAR(50) NOT NULL,
    trade_date DATE NOT NULL,
    aggregate_data NVARCHAR(MAX) NOT NULL, -- JSON serialized aggregate
    created_timestamp DATETIME2 DEFAULT GETDATE(),
    updated_timestamp DATETIME2 DEFAULT GETDATE(),
    CONSTRAINT ck_trade_version CHECK (version > 0)
);

CREATE TABLE LifecycleEvent (
    event_id VARCHAR(50) PRIMARY KEY,
    trade_id VARCHAR(50) NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    event_data NVARCHAR(MAX) NOT NULL, -- JSON serialized event
    sequence_number BIGINT NOT NULL,
    timestamp DATETIME2 NOT NULL,
    source_blotter_id VARCHAR(50),
    CONSTRAINT fk_event_trade FOREIGN KEY (trade_id) REFERENCES TradeAggregate(trade_id)
);
```

### Cashflow Schema
```sql
CREATE TABLE Cashflow (
    cashflow_id VARCHAR(50) PRIMARY KEY,
    trade_id VARCHAR(50) NOT NULL,
    position_id VARCHAR(50) NOT NULL,
    cashflow_type VARCHAR(20) NOT NULL,
    payer_party_id VARCHAR(50) NOT NULL,
    receiver_party_id VARCHAR(50) NOT NULL,
    currency CHAR(3) NOT NULL,
    amount DECIMAL(18,2) NOT NULL,
    settlement_date DATE NOT NULL,
    payment_type VARCHAR(20) NOT NULL,
    origin_event_id VARCHAR(50) NOT NULL,
    revision_number INTEGER DEFAULT 1,
    is_cancelled BIT DEFAULT 0,
    created_timestamp DATETIME2 DEFAULT GETDATE(),
    CONSTRAINT fk_cashflow_trade FOREIGN KEY (trade_id) REFERENCES TradeAggregate(trade_id)
);
```

## IBM MQ Integration Design

### Message Abstraction Layer
```java
public interface EventPublisher {
    void publish(String queueName, Object event);
    void publishWithCorrelationId(String queueName, String correlationId, Object event);
    CompletableFuture<Void> publishAsync(String queueName, Object event);
}

public interface EventConsumer {
    void subscribe(String queueName, EventHandler handler);
    void subscribeWithSelector(String queueName, String selector, EventHandler handler);
}

@Service
public class IBMQueueManager implements EventPublisher, EventConsumer {
    private final MQQueueManager queueManager;
    private final ObjectMapper objectMapper;
    private final ExecutorService executorService;
}
```

### Queue Configuration
```yaml
ibm-mq:
  queues:
    lifecycle-events: "LIFECYCLE.EVENTS"
    position-updates: "POSITION.UPDATES"
    cashflows-generated: "CASHFLOWS.GENERATED"
    settlement-instructions: "SETTLEMENT.INSTRUCTIONS"
    exceptions: "EXCEPTIONS.QUEUE"
  
  connection:
    host: "mq-server"
    port: 1414
    channel: "SYSTEM.DEF.SVRCONN"
    queue-manager: "QMGR1"
    username: "${MQ_USERNAME}"
    password: "${MQ_PASSWORD}"
```

## Error Handling & Resilience

### Exception Handling Strategy
```java
@Component
public class ExceptionHandler {
    private final DeadLetterQueuePublisher dlqPublisher;
    private final RetryPolicy retryPolicy;
    
    @RetryableTopic(
        attempts = "3",
        backoff = @Backoff(delay = 1000, multiplier = 2),
        dltStrategy = DltStrategy.FAIL_ON_ERROR
    )
    public void handleEvent(LifecycleEvent event) {
        // Event processing logic
    }
}
```

### Circuit Breaker Pattern
```java
@Component
public class ReferenceDataCircuitBreaker {
    private final CircuitBreaker circuitBreaker;
    
    public CompletableFuture<ReferenceData> getReferenceData(String key) {
        return circuitBreaker.executeSupplier(() -> 
            referenceDataService.getData(key)
        );
    }
}
```
